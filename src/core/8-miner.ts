import axios, { AxiosError } from 'axios';
import fs from 'fs';
import os from 'os';
import path from 'path';
import { Worker } from 'worker_threads';

import { Blockchain } from './2-blockchain';
import {
  broadcast,
  connectToPeer,
  initP2PServer,
  MessageType,
} from './6-p2p';
import { BalanceManager } from './balanceManager';
import { Block } from './block';
import config from './config.json';
import { TransactionManager } from './transaction';
import { logWithTimestamp } from './utils';

const serverIP = config.network.serverIP;
const serverPort = config.network.rpcPort;
const serverurl = `http://${serverIP}:${serverPort}`;
const peerconnecturl = `ws://${serverIP}:${config.network.p2pServerPort}`;
const p2pminerport = config.miner.p2pMinerPort;
const mineDifficulty = config.blockchain.difficulty;
const mineInterval = config.blockchain.miningInterval;
const minerwalletAddress = config.wallet.minerAddress;
const hashServerurl = `http://${config.network.hashServerIP}:${config.network.hashServerPort}`;
const cpuUtilization = config.mining.cpuUtilization;

// Ê∑ªÂä†ÈáçËØïÈÖçÁΩÆ
const MAX_RETRIES = 3;
const RETRY_DELAY = 5000;

export class Miner {
    minerAddress: string;
    blockchain: Blockchain;
    transactionManager: TransactionManager;
    isMining: boolean = false;
    miningInterval: number = mineInterval;
    newBlock: Block | null = null;
    lastSubmittedBlockHash: string | null = null;
    difficulty: number;

    constructor(minerAddress: string, difficulty: number, blockchain: Blockchain, balanceManager: BalanceManager) {
        this.minerAddress = minerAddress;
        this.difficulty = difficulty;
        this.blockchain = blockchain;
        this.transactionManager = new TransactionManager(blockchain, balanceManager);
    }

    async getLatestBlock() {
        let retries = 0;
        while (retries < MAX_RETRIES) {
            try {
                logWithTimestamp('üîç Fetching latest block from server...');
                const response = await axios.get(`${serverurl}/latest-block`, {
                    timeout: 10000,  // 10ÁßíË∂ÖÊó∂
                    headers: {
                        'Connection': 'keep-alive'
                    }
                });
                
                logWithTimestamp('üì¶ Successfully fetched latest block');
                logWithTimestamp(`‚îú‚îÄ‚îÄ Block Height: #${response.data.index}`);
                logWithTimestamp(`‚îî‚îÄ‚îÄ Block Hash: ${response.data.hash}`);
                
                return response.data;
            } catch (err: unknown) {
                retries++;
                const isLastRetry = retries === MAX_RETRIES;
                
                if (axios.isAxiosError(err)) {
                    const errorCode = err.code || 'UNKNOWN';
                    const errorMessage = err.message || 'Unknown error';
                    
                    logWithTimestamp(`‚ùå Network request failed (${retries}/${MAX_RETRIES})`);
                    logWithTimestamp(`‚îú‚îÄ‚îÄ Error Code: ${errorCode}`);
                    logWithTimestamp(`‚îú‚îÄ‚îÄ Error Message: ${errorMessage}`);
                    
                    if (err.code === 'ECONNRESET' || err.code === 'ECONNREFUSED') {
                        logWithTimestamp(`‚îú‚îÄ‚îÄ Server connection failed`);
                        logWithTimestamp(`‚îú‚îÄ‚îÄ Target Address: ${serverurl}`);
                    }
                    
                    if (!isLastRetry) {
                        logWithTimestamp(`‚îî‚îÄ‚îÄ Retrying in ${RETRY_DELAY/1000} seconds...`);
                        await this.pause(RETRY_DELAY);
                        continue;
                    }
                }
                
                if (isLastRetry) {
                    logWithTimestamp(`
‚ùå Unable to connect to server
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîß Suggestions:
‚îú‚îÄ‚îÄ 1. Check if the server is online (${serverurl})
‚îú‚îÄ‚îÄ 2. Check network connection
‚îú‚îÄ‚îÄ 3. Check firewall settings
‚îî‚îÄ‚îÄ 4. Check if the server port is open
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`);
                    this.stopMining();
                    throw new Error('Unable to connect to server, mining stopped');
                }
            }
        }
        throw new Error('Failed to fetch latest block');
    }

    async submitBlock(newBlock: Block) {
        logWithTimestamp(`üì§ Submitting new block to main node: ${JSON.stringify(newBlock)}`);
        try {
            if (!this.isValidBlock(newBlock)) {
                logWithTimestamp('‚ùå Found invalid block structure:', newBlock);
                return;
            }
            if (newBlock.hash === this.lastSubmittedBlockHash) {
                logWithTimestamp(`‚ö†Ô∏è Block ${newBlock.hash} has already been submitted, skipping duplicate submission.`);
                return;
            }

            // 1. First, get the latest block height
            const latestBlock = await this.getLatestBlock();
            const expectedIndex = latestBlock.index + 1;

            // 2. Verify block height
            if (newBlock.index !== expectedIndex) {
                logWithTimestamp(`‚ö†Ô∏è Block height mismatch, need to resynchronize`);
                logWithTimestamp(`‚îú‚îÄ‚îÄ Expected Height: ${expectedIndex}`);
                logWithTimestamp(`‚îú‚îÄ‚îÄ Current Height: ${newBlock.index}`);
                
                // Resynchronize blockchain
                await this.syncBlockchain();
                return;
            }

            // 3. Submit block, including Miner address
            const response = await axios.post(`${serverurl}/submit-block`, {
                block: newBlock,
                minerAddress: this.minerAddress
            });

            if (response.status === 200) {
                const reward = response.data.reward?.amount || 'pending';
                logWithTimestamp(`
‚ú® Block Submitted Successfully ‚ú®
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Block Information
‚îú‚îÄ‚îÄ üìè Height: #${newBlock.index}
‚îú‚îÄ‚îÄ üîó Hash: ${newBlock.hash}
‚îú‚îÄ‚îÄ ‚è±Ô∏è  Time: ${new Date(newBlock.timestamp).toLocaleString()}
‚îî‚îÄ‚îÄ üìù Transactions: ${newBlock.transactions.length}

üí∞ Reward Information
‚îú‚îÄ‚îÄ üë®‚Äçüíº Miner Address: ${this.minerAddress}
‚îî‚îÄ‚îÄ üíé Expected Reward: ${reward} RTF
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                `);
                
                this.lastSubmittedBlockHash = newBlock.hash;
                broadcast({ 
                    type: MessageType.NEW_BLOCK, 
                    data: {
                        block: newBlock,
                        minerAddress: this.minerAddress
                    }
                });
            } else {
                logWithTimestamp(`‚ö†Ô∏è Block submission returned non-200 status code: ${response.status}`);
                await this.retrySubmit(newBlock);
            }
        } catch (error) {
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 404) {
                    logWithTimestamp(`‚ö†Ô∏è Block submission failed, need to resynchronize`);
                    await this.syncBlockchain();
                    return;
                }
                logWithTimestamp(`‚ùå Error occurred during block submission: ${error.response?.data?.message || error.message}`);
            } else {
                logWithTimestamp('‚ùå Unknown error occurred during block submission:', error);
            }
            await this.retrySubmit(newBlock);
        }
    }

    isValidBlock(block: Block): boolean {
        return (
            typeof block.index !== 'undefined' &&
            !!block.timestamp &&
            Array.isArray(block.transactions) &&
            !!block.previousHash &&
            block.nonce >= 0 &&
            !!block.hash
        );
    }

    async retrySubmit(newBlock: Block) {
        const maxRetries = 3;
        const retryDelay = 3000;
        let retryCount = 0;

        while (retryCount < maxRetries) {
            retryCount++;
            logWithTimestamp(`‚è∏Ô∏è Pausing ${retryDelay/1000} seconds before retrying (${retryCount}/${maxRetries})...`);
            await this.pause(retryDelay);

            try {
                // Re-fetch the latest block height
                const latestBlock = await this.getLatestBlock();
                const expectedIndex = latestBlock.index + 1;

                if (newBlock.index < expectedIndex) {
                    logWithTimestamp('‚ö†Ô∏è Block is expired, stopping retry');
                    return;
                }

                await this.submitBlock(newBlock);
                return;
            } catch (error) {
                if (retryCount === maxRetries) {
                    logWithTimestamp('‚ùå Reached maximum retry attempts, stopping retry');
                    return;
                }
            }
        }
    }

    handleSubmitError(error: unknown, newBlock: Block) {
        const axiosError = error as AxiosError;
        if (axiosError.response) {
            logWithTimestamp(`‚ùå Error occurred during submission, server returned status code: ${axiosError.response.status}, response content: ${JSON.stringify(axiosError.response.data)}`);
        } else {
            logWithTimestamp('‚ùå Unknown error occurred during submission:', (error as Error).message);
        }
        this.retrySubmit(newBlock);
    }

    async startMining() {
        this.isMining = true;
        logWithTimestamp(`üöÄ Miner ${this.minerAddress} started mining with difficulty ${this.difficulty}...`);

        const cpuCount = os.cpus().length;
        logWithTimestamp(`üñ•Ô∏è  Detected ${cpuCount} CPU cores, preparing to start ${cpuCount} mining threads...`);

        while (this.isMining) {
            try {
                await this.syncBlockchain();
                let transactions = this.blockchain.getPendingTransactions();
                logWithTimestamp(`üßæ Pending transactions in transaction pool: ${transactions}`);

                const latestBlock = await this.getLatestBlock();
                logWithTimestamp(`üìè Current chain's latest block height: ${latestBlock.index}`);
                this.newBlock = new Block(
                    latestBlock.index + 1,
                    new Date().toISOString(),
                    transactions,
                    latestBlock.hash
                );
                logWithTimestamp('‚õèÔ∏è Starting to mine new block...');

                const minedBlocks = await this.mineWithWorkers(Math.ceil(cpuCount * cpuUtilization), this.difficulty);
                for (const minedBlock of minedBlocks) {
                    logWithTimestamp(`üíé Block mined! Hash: ${minedBlock.hash}`);
                    await this.submitBlock(minedBlock);
                }

                this.blockchain.pendingTransactions = [];
                await this.pause(this.miningInterval);
            } catch (err: unknown) {
                const error = err as Error;
                
                logWithTimestamp(`
‚ö†Ô∏è Mining Error Occurred
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îú‚îÄ‚îÄ ‚ùå Error Type: ${error instanceof Error ? error.name : 'Unknown'}
‚îú‚îÄ‚îÄ üìù Message: ${error instanceof Error ? error.message : 'Unknown error'}
‚îî‚îÄ‚îÄ üîÑ Retrying in 5 seconds...
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`);
                await this.pause(5000);
                
                // Try reconnecting
                try {
                    await this.getLatestBlock();
                    logWithTimestamp('‚úÖ Reconnected successfully, resuming mining...');
                    continue;
                } catch (reconnectErr) {
                    const reconnectError = reconnectErr as Error;
                    logWithTimestamp(`‚ùå Reconnection failed: ${reconnectError instanceof Error ? reconnectError.message : 'Unknown error'}`);
                    this.stopMining();
                }
            }
        }
    }

    private async mineWithWorkers(workerCount: number, difficulty: number): Promise<any[]> {
        const promises = [];
        let totalHashRate = 0;
        const startTime = Date.now();

        for (let i = 0; i < workerCount; i++) {
            promises.push(this.mineWithWorker(difficulty));
        }

        const results = await Promise.all(promises);
        const endTime = Date.now();
        const totalTime = (endTime - startTime) / 1000;

        results.forEach((result, index) => {
            const { stats } = result;
            logWithTimestamp(`‚îú‚îÄ‚îÄ Thread ${index + 1} Hashrate: ${stats.hashRate.toFixed(2)} H/s`);
            logWithTimestamp(`‚îÇ   ‚îú‚îÄ‚îÄ Attempts: ${stats.attempt}`);
            logWithTimestamp(`‚îÇ   ‚îî‚îÄ‚îÄ Time: ${stats.elapsedTime.toFixed(2)} seconds`);
            totalHashRate += stats.hashRate;
        });

        logWithTimestamp(`‚îî‚îÄ‚îÄ Total Hashrate: ${totalHashRate.toFixed(2)} H/s`);
        logWithTimestamp(`    ‚îú‚îÄ‚îÄ Total Time: ${totalTime.toFixed(2)} seconds`);
        logWithTimestamp(`    ‚îî‚îÄ‚îÄ Average per Thread: ${(totalHashRate / workerCount).toFixed(2)} H/s`);

        await this.submitHashRate(totalHashRate);

        return results.map(result => result.block);
    }

    private mineWithWorker(difficulty: number): Promise<any> {
        return new Promise((resolve, reject) => {
            const worker = new Worker('./minerWorker.ts', {
                workerData: { newBlock: this.newBlock, difficulty }
            });

            worker.on('message', (result: any) => {
                const { block, stats } = result;
                resolve({ block, stats });
            });

            worker.on('error', (error) => {
                reject(error);
            });

            worker.on('exit', (code) => {
                if (code !== 0) {
                    reject(new Error(`Worker stopped with exit code ${code}`));
                }
            });
        });
    }

    private async submitHashRate(hashRate: number) {
        try {
            const hashRateResponse = await axios.post(`${hashServerurl}/submit-hashrate`, {
                minerAddress: this.minerAddress,
                hashRate: hashRate,
                timestamp: new Date().toISOString()
            });

            if (hashRateResponse.status === 200) {
                logWithTimestamp(`‚úÖ Hashrate submitted successfully: ${hashRate.toFixed(2)} H/s`);
                logWithTimestamp(`‚îú‚îÄ‚îÄ Miner Address: ${this.minerAddress}`);
                logWithTimestamp(`‚îî‚îÄ‚îÄ Timestamp: ${new Date().toISOString()}`);
            } else {
                logWithTimestamp(`‚ö†Ô∏è Hashrate submission returned abnormal status: ${hashRateResponse.status}`);
            }

        } catch (error) {
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 404) {
                    logWithTimestamp('‚ö†Ô∏è Hashrate server not responding, will retry in the next round');
                } else {
                    logWithTimestamp(`‚ùå Hashrate submission failed: ${error.message}`);
                }
            } else {
                logWithTimestamp('‚ùå Unknown error occurred during hashrate submission:', error);
            }
        }
    }

    async syncBlockchain() {
        logWithTimestamp(`
üîÑ Starting Blockchain Synchronization
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
        
        try {
            const localHeight = this.blockchain.chain.length;
            logWithTimestamp(`‚îú‚îÄ‚îÄ üìä Local Block Height: #${localHeight}`);

            logWithTimestamp('‚îú‚îÄ‚îÄ üåê Fetching blockchain data from server...');
            const response = await axios.get(`${serverurl}/blockchain`);
            const blockchainData = response.data;
            const remoteHeight = blockchainData.chain.length;

            const heightDiff = remoteHeight - localHeight;
            logWithTimestamp(`‚îú‚îÄ‚îÄ üìà Server Block Height: #${remoteHeight}`);
            logWithTimestamp(`‚îú‚îÄ‚îÄ ${heightDiff > 0 ? '‚ö†Ô∏è' : '‚úÖ'} Height Difference: ${heightDiff}`);

            const dir = path.join(__dirname, './chaindata/');
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                logWithTimestamp('‚îú‚îÄ‚îÄ üìÅ Created data directory: chaindata/');
            }

            logWithTimestamp('‚îú‚îÄ‚îÄ üíæ Saving blockchain data...');
            fs.writeFileSync(
                path.join(dir, 'blockchain.json'), 
                JSON.stringify(blockchainData, null, 2)
            );

            this.blockchain.chain = blockchainData.chain;
            const latestBlock = this.blockchain.getLatestBlock();
            
            logWithTimestamp(`
‚úÖ Blockchain Sync Complete
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îú‚îÄ‚îÄ üìä Current Height: #${remoteHeight}
‚îú‚îÄ‚îÄ üîó Latest Block: ${latestBlock.hash}
‚îú‚îÄ‚îÄ ‚è±Ô∏è  Block Time: ${new Date(latestBlock.timestamp).toLocaleString()}
‚îú‚îÄ‚îÄ üìù Transactions: ${latestBlock.transactions.length}
‚îî‚îÄ‚îÄ üíæ Data saved to: chaindata/blockchain.json
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);

        } catch (err: unknown) {
            const error = err as Error;
            logWithTimestamp(`
‚ùå Blockchain Sync Failed
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îú‚îÄ‚îÄ üìù Error: ${error instanceof Error ? error.message : 'Unknown error'}
‚îú‚îÄ‚îÄ üîß Possible causes:
‚îÇ   ‚îú‚îÄ‚îÄ 1. Network connection unstable
‚îÇ   ‚îú‚îÄ‚îÄ 2. Server not responding
‚îÇ   ‚îî‚îÄ‚îÄ 3. Data format error
‚îî‚îÄ‚îÄ üí° Suggestion: Please check network connection and retry
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
            
            throw error;
        }
    }

    stopMining(): void {
        this.isMining = false;
        logWithTimestamp(`
‚õî Mining Stopped
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îú‚îÄ‚îÄ üìç Miner Address: ${this.minerAddress}
‚îú‚îÄ‚îÄ ‚è±Ô∏è  Stop Time: ${new Date().toLocaleString()}
‚îî‚îÄ‚îÄ üí° Use startMining() to resume mining
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`);
    }

    pause(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}


// Main program start



const blockchain = new Blockchain();
const balanceManager = new BalanceManager();

initP2PServer(p2pminerport, blockchain);

const miner = new Miner(minerwalletAddress, mineDifficulty, blockchain, balanceManager);
miner.startMining();

connectToPeer(peerconnecturl, blockchain);

// Print startup configuration information
logWithTimestamp(`
üåü RTF Chain Miner Started üåü
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìå Basic Configuration
‚îú‚îÄ‚îÄ üíª Miner Address: ${minerwalletAddress}
‚îú‚îÄ‚îÄ üîß Mining Difficulty: ${mineDifficulty}
‚îú‚îÄ‚îÄ ‚è≥ Mining Interval: ${mineInterval} ms
‚îú‚îÄ‚îÄ üéØ CPU Utilization: ${cpuUtilization * 100}%
‚îî‚îÄ‚îÄ üí™ CPU Cores: ${os.cpus().length}

üåê Network Configuration
‚îú‚îÄ‚îÄ üì° RPC Server: ${serverurl}
‚îú‚îÄ‚îÄ üîó P2P Server: ${peerconnecturl}
‚îú‚îÄ‚îÄ üìä Hashrate Server: ${hashServerurl}
‚îî‚îÄ‚îÄ üö™ Local P2P Port: ${p2pminerport}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`);
